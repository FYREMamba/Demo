// FYRE Recon Team - Real Tool Integration
// Replaces simulated reconnaissance with actual security tools

const { exec, spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const dns = require('dns').promises;

class FyreReconTeam {
    constructor() {
        this.toolsPath = process.env.TOOLS_PATH || '/opt/security-tools';
        this.outputDir = process.env.OUTPUT_DIR || './recon-results';
        this.results = {
            subdomains: new Set(),
            liveHosts: new Set(),
            openPorts: new Map(),
            technologies: new Map(),
            certificates: new Map()
        };
    }

    // Main reconnaissance workflow orchestrated by the main system
    async executeReconOrder(target, scope = 'comprehensive') {
        console.log(`[FYRE Recon] Processing recon order for ${target}`);
        
        try {
            // Create output directory for this target
            const targetDir = path.join(this.outputDir, target.replace(/\./g, '_'));
            await fs.mkdir(targetDir, { recursive: true });

            // Phase 1: Subdomain Discovery
            console.log(`[FYRE Recon] Phase 1: Subdomain enumeration`);
            await this.runSubdomainDiscovery(target, targetDir);

            // Phase 2: Live Host Detection
            console.log(`[FYRE Recon] Phase 2: Live host detection`);
            await this.detectLiveHosts(targetDir);

            // Phase 3: Port Scanning (if comprehensive)
            if (scope === 'comprehensive') {
                console.log(`[FYRE Recon] Phase 3: Port scanning`);
                await this.scanCommonPorts(targetDir);
            }

            // Phase 4: Technology Fingerprinting
            console.log(`[FYRE Recon] Phase 4: Technology detection`);
            await this.fingerprintTechnologies(targetDir);

            // Phase 5: SSL Certificate Analysis
            console.log(`[FYRE Recon] Phase 5: Certificate analysis`);
            await this.analyzeCertificates(targetDir);

            // Compile final results
            const reconReport = this.compileResults(target);
            await this.saveResults(targetDir, reconReport);

            console.log(`[FYRE Recon] Recon complete. Found ${this.results.subdomains.size} subdomains, ${this.results.liveHosts.size} live hosts`);
            
            return reconReport;

        } catch (error) {
            console.error(`[FYRE Recon] Error during reconnaissance: ${error.message}`);
            throw error;
        }
    }

    // Real subdomain discovery using multiple tools
    async runSubdomainDiscovery(target, outputDir) {
        const subdomainFile = path.join(outputDir, 'subdomains.txt');
        const discoveredSubs = new Set();

        try {
            // Tool 1: Subfinder (passive)
            console.log(`[FYRE Recon] Running subfinder for ${target}`);
            const subfinderResults = await this.runSubfinder(target);
            subfinderResults.forEach(sub => discoveredSubs.add(sub));

            // Tool 2: Amass enum (passive + active)
            console.log(`[FYRE Recon] Running amass for ${target}`);
            const amassResults = await this.runAmass(target);
            amassResults.forEach(sub => discoveredSubs.add(sub));

            // Tool 3: Certificate transparency (crt.sh API)
            console.log(`[FYRE Recon] Checking certificate transparency`);
            const ctResults = await this.queryCertificateTransparency(target);
            ctResults.forEach(sub => discoveredSubs.add(sub));

            // Save all discovered subdomains
            const allSubs = Array.from(discoveredSubs).sort();
            await fs.writeFile(subdomainFile, allSubs.join('\n'));
            
            allSubs.forEach(sub => this.results.subdomains.add(sub));
            console.log(`[FYRE Recon] Discovered ${allSubs.length} unique subdomains`);

        } catch (error) {
            console.error(`[FYRE Recon] Subdomain discovery failed: ${error.message}`);
            throw error;
        }
    }

    // Execute subfinder tool
    runSubfinder(target) {
        return new Promise((resolve, reject) => {
            const subfinderPath = path.join(this.toolsPath, 'subfinder');
            const cmd = `${subfinderPath} -d ${target} -silent`;
            
            exec(cmd, { timeout: 30000 }, (error, stdout, stderr) => {
                if (error && error.code !== 'TIMEOUT') {
                    console.warn(`[FYRE Recon] Subfinder warning: ${error.message}`);
                }
                
                const subdomains = stdout
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line && line.includes('.'))
                    .filter(line => !line.startsWith('[') && !line.includes(' '));
                
                resolve(subdomains);
            });
        });
    }

    // Execute amass enum
    runAmass(target) {
        return new Promise((resolve, reject) => {
            const amassPath = path.join(this.toolsPath, 'amass');
            const cmd = `${amassPath} enum -passive -d ${target}`;
            
            exec(cmd, { timeout: 45000 }, (error, stdout, stderr) => {
                if (error && error.code !== 'TIMEOUT') {
                    console.warn(`[FYRE Recon] Amass warning: ${error.message}`);
                }
                
                const subdomains = stdout
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line && line.includes('.'))
                    .filter(line => !line.startsWith('['));
                
                resolve(subdomains);
            });
        });
    }

    // Query certificate transparency logs via crt.sh API
    async queryCertificateTransparency(target) {
        try {
            const https = require('https');
            const url = `https://crt.sh/?q=%.${target}&output=json`;
            
            return new Promise((resolve, reject) => {
                https.get(url, (res) => {
                    let data = '';
                    res.on('data', chunk => data += chunk);
                    res.on('end', () => {
                        try {
                            const certificates = JSON.parse(data);
                            const subdomains = new Set();
                            
                            certificates.forEach(cert => {
                                const names = cert.name_value.split('\n');
                                names.forEach(name => {
                                    const cleanName = name.trim().toLowerCase();
                                    if (cleanName.includes(target) && 
                                        !cleanName.includes('*') && 
                                        cleanName.length < 100) {
                                        subdomains.add(cleanName);
                                    }
                                });
                            });
                            
                            resolve(Array.from(subdomains));
                        } catch (parseError) {
                            console.warn(`[FYRE Recon] CT parsing failed: ${parseError.message}`);
                            resolve([]);
                        }
                    });
                }).on('error', (err) => {
                    console.warn(`[FYRE Recon] CT query failed: ${err.message}`);
                    resolve([]);
                }).setTimeout(15000, () => {
                    console.warn(`[FYRE Recon] CT query timeout`);
                    resolve([]);
                });
            });
        } catch (error) {
            console.warn(`[FYRE Recon] CT error: ${error.message}`);
            return [];
        }
    }

    // Detect live hosts using httpx
    async detectLiveHosts(outputDir) {
        const subdomainFile = path.join(outputDir, 'subdomains.txt');
        const liveFile = path.join(outputDir, 'live_hosts.txt');
        
        try {
            const httpxPath = path.join(this.toolsPath, 'httpx');
            const cmd = `${httpxPath} -l ${subdomainFile} -silent -timeout 10 -retries 2`;
            
            return new Promise((resolve, reject) => {
                exec(cmd, { timeout: 60000 }, async (error, stdout, stderr) => {
                    if (error && error.code !== 'TIMEOUT') {
                        console.warn(`[FYRE Recon] Httpx warning: ${error.message}`);
                    }
                    
                    const liveHosts = stdout
                        .split('\n')
                        .map(line => line.trim())
                        .filter(line => line.startsWith('http'));
                    
                    await fs.writeFile(liveFile, liveHosts.join('\n'));
                    liveHosts.forEach(host => this.results.liveHosts.add(host));
                    
                    console.log(`[FYRE Recon] Found ${liveHosts.length} live hosts`);
                    resolve(liveHosts);
                });
            });
        } catch (error) {
            console.error(`[FYRE Recon] Live host detection failed: ${error.message}`);
            throw error;
        }
    }

    // Port scanning with nmap
    async scanCommonPorts(outputDir) {
        const liveFile = path.join(outputDir, 'live_hosts.txt');
        const portFile = path.join(outputDir, 'port_scan.txt');
        
        try {
            const liveHosts = await fs.readFile(liveFile, 'utf8');
            const hosts = liveHosts.split('\n')
                .filter(line => line.trim())
                .map(url => new URL(url).hostname)
                .slice(0, 10); // Limit to first 10 hosts for performance
            
            if (hosts.length === 0) return;
            
            const nmapPath = path.join(this.toolsPath, 'nmap');
            const hostList = hosts.join(',');
            const cmd = `${nmapPath} -sS -T4 -p 21,22,23,25,53,80,443,993,995,8080,8443 ${hostList}`;
            
            return new Promise((resolve, reject) => {
                exec(cmd, { timeout: 120000 }, async (error, stdout, stderr) => {
                    if (error && error.code !== 'TIMEOUT') {
                        console.warn(`[FYRE Recon] Nmap warning: ${error.message}`);
                    }
                    
                    await fs.writeFile(portFile, stdout);
                    this.parseNmapResults(stdout);
                    
                    console.log(`[FYRE Recon] Port scan completed`);
                    resolve();
                });
            });
        } catch (error) {
            console.warn(`[FYRE Recon] Port scanning failed: ${error.message}`);
        }
    }

    // Parse nmap output for open ports
    parseNmapResults(nmapOutput) {
        const lines = nmapOutput.split('\n');
        let currentHost = null;
        
        lines.forEach(line => {
            // Match host lines
            const hostMatch = line.match(/Nmap scan report for (.+)/);
            if (hostMatch) {
                currentHost = hostMatch[1];
                this.results.openPorts.set(currentHost, []);
                return;
            }
            
            // Match open port lines
            const portMatch = line.match(/(\d+)\/tcp\s+open\s+(.+)/);
            if (portMatch && currentHost) {
                const port = parseInt(portMatch[1]);
                const service = portMatch[2].trim();
                this.results.openPorts.get(currentHost).push({ port, service });
            }
        });
    }

    // Technology fingerprinting
    async fingerprintTechnologies(outputDir) {
        const liveFile = path.join(outputDir, 'live_hosts.txt');
        const techFile = path.join(outputDir, 'technologies.json');
        
        try {
            const liveHosts = await fs.readFile(liveFile, 'utf8');
            const hosts = liveHosts.split('\n')
                .filter(line => line.trim())
                .slice(0, 5); // Limit for performance
            
            for (const host of hosts) {
                if (!host) continue;
                
                try {
                    const tech = await this.fingerprintSingleHost(host);
                    this.results.technologies.set(host, tech);
                } catch (error) {
                    console.warn(`[FYRE Recon] Tech fingerprint failed for ${host}: ${error.message}`);
                }
            }
            
            const techData = Object.fromEntries(this.results.technologies);
            await fs.writeFile(techFile, JSON.stringify(techData, null, 2));
            
        } catch (error) {
            console.warn(`[FYRE Recon] Technology fingerprinting failed: ${error.message}`);
        }
    }

    // Fingerprint a single host
    async fingerprintSingleHost(url) {
        return new Promise((resolve, reject) => {
            const https = require('https');
            const http = require('http');
            
            const client = url.startsWith('https') ? https : http;
            const request = client.get(url, { timeout: 10000 }, (res) => {
                const headers = res.headers;
                const tech = {
                    server: headers.server || 'Unknown',
                    framework: this.detectFramework(headers),
                    statusCode: res.statusCode
                };
                resolve(tech);
            });
            
            request.on('error', (error) => {
                resolve({ error: error.message });
            });
            
            request.on('timeout', () => {
                request.destroy();
                resolve({ error: 'Timeout' });
            });
        });
    }

    // Detect web framework from headers
    detectFramework(headers) {
        const frameworks = [];
        
        if (headers['x-powered-by']) {
            frameworks.push(headers['x-powered-by']);
        }
        if (headers['x-framework']) {
            frameworks.push(headers['x-framework']);
        }
        if (headers.server) {
            if (headers.server.includes('nginx')) frameworks.push('Nginx');
            if (headers.server.includes('Apache')) frameworks.push('Apache');
            if (headers.server.includes('IIS')) frameworks.push('IIS');
        }
        
        return frameworks.length > 0 ? frameworks : ['Unknown'];
    }

    // SSL Certificate analysis
    async analyzeCertificates(outputDir) {
        const liveFile = path.join(outputDir, 'live_hosts.txt');
        const certFile = path.join(outputDir, 'certificates.json');
        
        try {
            const liveHosts = await fs.readFile(liveFile, 'utf8');
            const httpsHosts = liveHosts.split('\n')
                .filter(line => line.trim() && line.startsWith('https'))
                .slice(0, 5); // Limit for performance
            
            for (const host of httpsHosts) {
                try {
                    const certInfo = await this.getCertificateInfo(host);
                    this.results.certificates.set(host, certInfo);
                } catch (error) {
                    console.warn(`[FYRE Recon] Cert analysis failed for ${host}: ${error.message}`);
                }
            }
            
            const certData = Object.fromEntries(this.results.certificates);
            await fs.writeFile(certFile, JSON.stringify(certData, null, 2));
            
        } catch (error) {
            console.warn(`[FYRE Recon] Certificate analysis failed: ${error.message}`);
        }
    }

    // Get SSL certificate information
    async getCertificateInfo(url) {
        return new Promise((resolve, reject) => {
            const https = require('https');
            const { URL } = require('url');
            
            try {
                const parsedUrl = new URL(url);
                const options = {
                    hostname: parsedUrl.hostname,
                    port: parsedUrl.port || 443,
                    method: 'GET',
                    timeout: 10000
                };
                
                const req = https.get(options, (res) => {
                    const cert = res.socket.getPeerCertificate();
                    
                    if (cert) {
                        resolve({
                            subject: cert.subject,
                            issuer: cert.issuer,
                            validFrom: cert.valid_from,
                            validTo: cert.valid_to,
                            serialNumber: cert.serialNumber,
                            subjectAltNames: cert.subjectaltname
                        });
                    } else {
                        resolve({ error: 'No certificate found' });
                    }
                });
                
                req.on('error', (error) => {
                    resolve({ error: error.message });
                });
                
                req.on('timeout', () => {
                    req.destroy();
                    resolve({ error: 'Timeout' });
                });
                
            } catch (error) {
                resolve({ error: error.message });
            }
        });
    }

    // Compile all results into final report
    compileResults(target) {
        const report = {
            target: target,
            timestamp: new Date().toISOString(),
            summary: {
                subdomainsFound: this.results.subdomains.size,
                liveHosts: this.results.liveHosts.size,
                openPorts: Array.from(this.results.openPorts.values()).flat().length,
                certificatesAnalyzed: this.results.certificates.size
            },
            data: {
                subdomains: Array.from(this.results.subdomains),
                liveHosts: Array.from(this.results.liveHosts),
                openPorts: Object.fromEntries(this.results.openPorts),
                technologies: Object.fromEntries(this.results.technologies),
                certificates: Object.fromEntries(this.results.certificates)
            },
            recommendations: this.generateRecommendations()
        };
        
        return report;
    }

    // Generate security recommendations based on findings
    generateRecommendations() {
        const recommendations = [];
        
        // Check for exposed services
        this.results.openPorts.forEach((ports, host) => {
            ports.forEach(({ port, service }) => {
                if ([21, 23, 3389].includes(port)) {
                    recommendations.push({
                        severity: 'High',
                        type: 'Exposed Service',
                        description: `${service} (port ${port}) exposed on ${host}`,
                        remediation: 'Consider closing unnecessary ports or restricting access'
                    });
                }
            });
        });
        
        // Check certificate expiration
        this.results.certificates.forEach((cert, host) => {
            if (cert.validTo) {
                const expiry = new Date(cert.validTo);
                const now = new Date();
                const daysUntilExpiry = Math.floor((expiry - now) / (1000 * 60 * 60 * 24));
                
                if (daysUntilExpiry < 30) {
                    recommendations.push({
                        severity: 'Medium',
                        type: 'Certificate Expiration',
                        description: `SSL certificate for ${host} expires in ${daysUntilExpiry} days`,
                        remediation: 'Renew SSL certificate before expiration'
                    });
                }
            }
        });
        
        return recommendations;
    }

    // Save final results to file
    async saveResults(outputDir, report) {
        const 
